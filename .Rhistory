minaseq <- with(data.frame(t(paramMeans)), (Fin+h)*(m+deltaseq)/e/Fin)
ESdelta <- with(data.frame(t(paramMeans)), sqrt(m*omega))
ESdelta
abline(h=ESdelta, lty=2)
par(mfrow=c(2,2), mar=c(2,2,0.5,0.5), oma=c(2,2,0,0))
for (j in 1:16) {
y <- x[[best.sims[j]]][[1]]
extant.ids <- which(is.infinite(y$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y$ancID[descendent]
}
}
plot.new()
plot.window(xlim=range(y$bTime), ylim=range(y$d))
axis(1); axis(2); box('plot')
for (i in 1:length(pedigrees))
lines(y[rev(pedigrees[[i]]),c('bTime','d')], col=ifelse(y[rev(pedigrees[[i]])[1],'a']>15,1,2))
abline(h=ESdelta, lty=2)
}
par(mfrow=c(4,4), mar=c(2,2,0.5,0.5), oma=c(2,2,0,0))
for (j in 1:16) {
y <- x[[best.sims[j]]][[1]]
extant.ids <- which(is.infinite(y$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y$ancID[descendent]
}
}
plot.new()
plot.window(xlim=range(y$bTime), ylim=range(y$d))
axis(1); axis(2); box('plot')
for (i in 1:length(pedigrees))
lines(y[rev(pedigrees[[i]]),c('bTime','d')], col=ifelse(y[rev(pedigrees[[i]])[1],'a']>15,1,2))
abline(h=ESdelta, lty=2)
}
mtext("Time",side=1, line=1, outer=TRUE)
mtext("Drug susceptibility",side=2, line=1, outer=TRUE)
x[[1]][[2]]
x[[1]][[1]] %>% head(60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits50_2.RDS")
x[[1]][[2]] %>% head(.,60)
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits20_2.RDS")
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits130_2.RDS")
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits140_2.RDS")
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits135_2.RDS")
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits135_2.RDS")
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits135_2.RDS")
lapply(x, function(y) (y[[2]] %>% tail(.,1))$N
)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits135_2.RDS")
lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist
rev(sort(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits145_2.RDS")
rev(sort(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits155_2.RDS")
rev(sort(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))
x[[1]][[1]] %>% head(.,60)
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits145_2.RDS")
rev(sort(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))
x <- readRDS("Sim_5-6-22_files/out_initialPops25_initialTraits140_2.RDS")
rev(sort(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))
## Find 16 populations that persisted
best.sims <- rev(order(lapply(x, function(y) (y[[2]] %>% tail(.,1))$N) %>% unlist))[1:16]
par(mfrow=c(4,4), mar=c(2,2,0.5,0.5), oma=c(2,2,0,0))
for (j in 1:16) {
y <- x[[best.sims[j]]][[1]]
extant.ids <- which(is.infinite(y$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y$ancID[descendent]
}
}
plot.new()
plot.window(xlim=range(y$bTime), ylim=range(y$d))
axis(1); axis(2); box('plot')
for (i in 1:length(pedigrees))
lines(y[rev(pedigrees[[i]]),c('bTime','d')], col=ifelse(y[rev(pedigrees[[i]])[1],'a']>15,1,2))
abline(h=ESdelta, lty=2)
}
mtext("Time",side=1, line=0.5, outer=TRUE)
mtext("Drug susceptibility",side=2, line=0.5, outer=TRUE)
y = x[[1]]
extant.ids <- which(is.infinite(y[[1]]$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y$ancID[descendent]
}
}
extant.ids <- which(is.infinite(y[[1]]$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y[[1]]$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y[[1]]$ancID[descendent]
}
}
extant.ids <- which(is.infinite(y[[1]]$dTime))
extant.ids
y[[1]]$dTime
y[[1]]
y[[2]]
y[[2]]$N
max(y[[2]]$N)
min(y[[2]]$N)
y = x[[50]]
tail(y[[2]])
tail(x[[50]][[2]])
tail(x[[51]][[2]])
y = x[[51]]
extant.ids <- which(is.infinite(y[[1]]$dTime))
pedigrees <- vector(mode='list', length=length(extant.ids))
for (i in 1:length(pedigrees)) {
pedigrees[[i]] <- c(extant.ids[i])
ancestor <- y[[1]]$ancID[extant.ids[i]]
while(!is.na(ancestor)) {
pedigrees[[i]] <- c(pedigrees[[i]], ancestor)
descendent <- ancestor
ancestor <- y[[1]]$ancID[descendent]
}
}
pedigrees
lapply(pedigrees, function(p) rev(p)[1])
lapply(pedigrees, function(p) rev(p)[1]) %>% unlist
y[[1]]
knitr::opts_chunk$set(echo = TRUE)
library(rvest)
library(tidyverse)
simple <- read_html("https://biosci.unl.edu/directory")
simple %>%
html_nodes("section.faculty-listing") %>%
map_df(~{
group <- .x %>% html_nodes('h2.group-name') %>% html_text()
name <- .x %>% html_nodes('.person-info h3') %>% html_text() %>% str_trim()
email <- .x %>% html_nodes('.email') %>% html_text()
tibble(group, name, email)
}) -> extract
extract
setwd("~/")
write.csv(extract,"sbsEmails.csv")
extract
write.csv(extract,file="~/sbsEmails.csv")
library(deSolve)
?ode
seq(0,100,by=5)
times <- seq(0,100,by=0.1)
times <- seq(0,100,by=0.1)
params <- c(u1=4.99, u2=1.5, K1=5.97, K2=0.36, m1=0.1, m2=0.1, Y1=1, Y2=1, interval=5)
seq(interval,max(times)-interval,by=interval)
interval = 5
seq(interval,max(times)-interval,by=interval)
seq(interval,max(times)-interval,by=interval) %>% length
Rin = 1000
rep(c(Rin,0), length=length(seq(interval,max(times)-interval,by=interval)))
Rin <-
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
eventdat
model <- function(t, y, params) {
Rin <- y[1] ## make this a variable so its value can be controlled by a switch function
R <- y[2] ## resource
N1 <- y[3]
N2 <- y[4]
u1 <- unname(params["u1"]) ## max growth rate
u2 <- unname(params["u2"])
K1 <- unname(params["K1"]) ## Michaelis-Menten half-saturation constant
K2 <- unname(params["K2"])
m1 <- unname(params["m1"]) ## maintenance rate
m2 <- unname(params["m2"])
Y1 <- unname(params["Y1"]) ## yield coefficient
Y2 <- unname(params["Y2"])
dRindt <- 0 ## this has no dynamics because it is a fixed value that changes at discrete times
dRdt <- Rin - 1/Y1 * u1 * R/(K1+R) * N1 - 1/Y2 * u2 * R/(K2+R)
dN1dt <- (u1 * R/(K1+R) - m1) * N1
dN2dt <- (u2 * R/(K2+R) - m2) * N2
return(list(c(dRindt,dRdt,dN1dt,dN2dt)))
}
times <- seq(0,100,by=0.1)
params <- c(u1=4.99, u2=1.5, K1=5.97, K2=0.36, m1=0.1, m2=0.1, Y1=1, Y2=1)
interval <- 5
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=, N2=1)
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
out <- ode(func=model, y=y0, times=times, params=params, events=list(data=eventdat))
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
head(out)
plot(out[,c(1,2)])
plot(out[,c(1,3)])
plot(out[,c(1,4)])
plot(out[,c(1,5)])
plot(out[,c(1,3)])
plot(out[,c(1,3)], type='l')
tail(out)
plot(out[1:101,c(1,4)])
plot(out[1:101,c(1,5)])
plot(out[1:101,c(1,4)])
plot(out[1:101,c(1,5)])
interval <- 2
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[1:101,c(1,4)])
plot(out[1:101,c(1,5)])
plot(out[1:101,c(1,4)])
tail(out)
plot(out[1:101,c(1,3)])
params
t(params)
data.frame(t(params))
with(data.frame(t(params)), K1*m/(u1-m)
)
with(data.frame(t(params)), K1*m1/(u1-m1))
with(data.frame(t(params)), K2*m2/(u2-m2))
## For this set of parameters,
## R*_1 = with(data.frame(t(params)), K1*m1/(u1-m1)) = 0.122
## R*_2 = with(data.frame(t(params)), K2*m2/(u2-m2)) = 0.026
params <- c(u1=4.99, u2=1.5, K1=5.97, K2=0.36, m1=1, m2=1, Y1=1, Y2=1)
with(data.frame(t(params)), K2*m2/(u2-m2))
with(data.frame(t(params)), K1*m1/(u1-m1))
## For this set of parameters,
## R*_1 = with(data.frame(t(params)), K1*m1/(u1-m1)) = 0.122
## R*_2 = with(data.frame(t(params)), K2*m2/(u2-m2)) = 0.026
params <- c(u1=4.99, u2=1.5, K1=5.97, K2=0.36, m1=1, m2=1, Y1=1, Y2=1)
interval <- 2
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
tail(out)
interval <- 10
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
tail(out)
interval <- 1
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[1:101,c(1,3)])
plot(out[1:101,c(1,4)])
plot(out[1:101,c(1,5)])
interval <- 0.01
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
eventdat
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
interval <- 1
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## never turn off resource influx - check to make sure the model is working properly
## N2 should exclude N1 in this scenario
out <- ode(func=model, y=y0, times=times, parms=params)
tail(out)
plot(out[,c(1,3)])
plot(out[,c(1,4)])
plot(out[,c(1,5)])
dRdt <- Rin - 1/Y1 * u1 * R/(K1+R) * N1 - 1/Y2 * u2 * R/(K2+R) * N2
model <- function(t, y, params) {
Rin <- y[1] ## make this a variable so its value can be controlled by a switch function
R <- y[2] ## resource
N1 <- y[3]
N2 <- y[4]
u1 <- unname(params["u1"]) ## max growth rate
u2 <- unname(params["u2"])
K1 <- unname(params["K1"]) ## Michaelis-Menten half-saturation constant
K2 <- unname(params["K2"])
m1 <- unname(params["m1"]) ## maintenance rate
m2 <- unname(params["m2"])
Y1 <- unname(params["Y1"]) ## yield coefficient
Y2 <- unname(params["Y2"])
dRindt <- 0 ## this has no dynamics because it is a fixed value that changes at discrete times
dRdt <- Rin - 1/Y1 * u1 * R/(K1+R) * N1 - 1/Y2 * u2 * R/(K2+R) * N2
dN1dt <- (u1 * R/(K1+R) - m1) * N1
dN2dt <- (u2 * R/(K2+R) - m2) * N2
return(list(c(dRindt,dRdt,dN1dt,dN2dt)))
}
## never turn off resource influx - check to make sure the model is working properly
## N2 should exclude N1 in this scenario
out <- ode(func=model, y=y0, times=times, parms=params)
tail(out)
interval <- 5
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
tail(out)
plot(out[1:101,c(1,5)])
plot(out[,c(1,5)])
plot(out[,c(1,5)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,3)], type='l')
## At this interval, there is no coexistence - the fast growing species outcompetes the slow-growing species
interval <- 1
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
times <- seq(0,40,by=0.1)
## For this set of parameters,
## R*_1 = with(data.frame(t(params)), K1*m1/(u1-m1)) = 0.122
## R*_2 = with(data.frame(t(params)), K2*m2/(u2-m2)) = 0.026
params <- c(u1=4.99, u2=1.5, K1=5.97, K2=0.36, m1=1, m2=1, Y1=1, Y2=1)
## At this interval, there is no coexistence - the fast growing species outcompetes the slow-growing species
interval <- 5
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## At this interval, there is no coexistence - the fast growing species outcompetes the slow-growing species
interval <- 1
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## still no coexistence here
interval <- 0.25
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
tail(out)
## still no coexistence here
interval <- 0.2
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## still no coexistence here
interval <- 0.1
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## still no coexistence here
interval <- 0.01
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## still no coexistence here
interval <- 0.05
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
times <- seq(0,100,by=interval)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
tail(out)
## still no coexistence here
interval <- 0.01
Rin <- 1000
y0 <- c(Rin=Rin, R=Rin, N1=1, N2=1)
times <- seq(0,100,by=interval)
## cycle resource influx on and off
eventdat <- data.frame(var="Rin",
time=seq(interval,max(times)-interval,by=interval), ## change the value of "by" to change how often food is influxing
value=rep(c(0,Rin), length=length(seq(interval,max(times)-interval,by=interval))), ## this assumes the resources starts "on" and then shuts off
method="rep")
out <- ode(func=model, y=y0, times=times, parms=params, events=list(data=eventdat))
plot(out[,c(1,3)], type='l')
plot(out[,c(1,4)], type='l')
plot(out[,c(1,5)], type='l')
## never turn off resource influx - check to make sure the model is working properly
## N2 should exclude N1 in this scenario, and it does
out0 <- ode(func=model, y=y0, times=times, parms=params)
tail(out0)
library(spatstat)
data(sasq)
sasq
sasq <- readRDS("~/Downloads/sasquatch.rds")
sasq
sasq_by_month <- split(sasq, "month", un = TRUE)
# Plot monthly maps
plot(sasq_by_month)
par(mar=rep(0,4), oma=rep(0,4))
sasq_by_month <- split(sasq, "month", un = TRUE)
# Plot monthly maps
plot(sasq_by_month)
# Histogram the dates of the sightings, grouped by year
hist(marks(sasq)$date, "year", freq = TRUE)
# Histogram the dates of the sightings, grouped by year
hist(marks(sasq)$date, "year", freq = TRUE)
par(mar=rep(4,4))
# Histogram the dates of the sightings, grouped by year
hist(marks(sasq)$date, "year", freq = TRUE)
# Plot and tabulate the calendar month of all the sightings
plot(table(marks(sasq)$month))
# Plot unmarked points
plot(unmark(sasq))
?stmctest
??stmctest
library(splanc)
library(splancs)
install.packages("splancs")
library(splancs)
?stmctest
## BONUS: use Moran I-test to ask whether there is spatial autocorrelation
# Make neighbor list
borough_nb <- poly2nb(london)
?Variogram
ph_vgm <- variogram(pH ~ x + y, ca_geo[!miss, ])
setwd("~/immunoparasite")
library(Rcpp)
sourceCpp("nested_model.cpp")
